<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>üéÆ Sensor Shooter Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: rgb(154, 154, 245);
            color: white;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: rgb(39, 28, 28);
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .back-to-main {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            text-decoration: none;
            z-index: 200;
            font-size: 1.1em;
            transition: background 0.3s ease;
        }

        .back-to-main:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }

        .countdown-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            color: white;
        }

        .countdown-number-container {
            font-size: 5rem;
            font-weight: bold;
            text-align: center;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 150;
        }

        .game-info {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 1.1em;
        }

        .top-left {
            top: 20px;
            left: 20px;
        }

        .top-right {
            top: 20px;
            right: 200px;
        }

        .sensor-status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            color: white;
            font-size: 0.9em;
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            color: white;
            text-align: center;
        }

        .game-over button {
            background: #4ecdc4;
            border: none;
            color: white;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .game-over button:hover {
            background: #5dddd4;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Î©îÏù∏ Î©îÎâ¥ Î≤ÑÌäº (ÌïÑÏàò) -->
        <a href="/" class="back-to-main">üè† Î©îÏù∏ÏúºÎ°ú</a>
        
        <!-- Î°úÎî© ÌôîÎ©¥ (ÌïÑÏàò) -->
        <div class="loading" id="loadingScreen">
            <h1>üéÆ Sensor Shooter Game</h1>
            <p>Í≤åÏûÑÏùÑ Ï§ÄÎπÑÌïòÎäî Ï§ë...</p>
        </div>

        <!-- Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌôîÎ©¥ -->
        <div class="countdown-screen" id="countdownScreen">
            <div class="countdown-number-container">
                <span id="countdownNumber">3</span>
            </div>
        </div>
        
        <!-- Í≤åÏûÑ Ï∫îÎ≤ÑÏä§ (ÌïÑÏàò) -->
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <!-- UI Ïò§Î≤ÑÎ†àÏù¥ -->
        <div class="ui-overlay">
            <div class="game-info top-left">
                <span>Ï†êÏàò: <span id="scoreDisplay">0</span></span>
            </div>
            <div class="game-info top-right">
                <span>Ï≤¥Î†•: <span id="healthDisplay">100</span></span>
            </div>

            <!-- ÏÑºÏÑú ÏÉÅÌÉú (ÌïÑÏàò) -->
            <div class="sensor-status">
                <div id="sensorConnection">üì° ÏÑºÏÑú Ïó∞Í≤∞ ÎåÄÍ∏∞Ï§ë...</div>
                <div>Aim X: <span id="aimX">0</span> | Aim Y: <span id="aimY">0</span></div>
                <div>Accel Mag: <span id="accelMag">0</span></div>
            </div>
        </div>
        
        <!-- Í≤åÏûÑ Ïò§Î≤Ñ ÌôîÎ©¥ (Í∂åÏû•) -->
        <div class="game-over" id="gameOverScreen">
            <h2>üéÆ Í≤åÏûÑ Ï¢ÖÎ£å!</h2>
            <p>ÏµúÏ¢Ö Ï†êÏàò: <span id="finalScore">0</span></p>
            <button onclick="restartGame()">Îã§Ïãú ÏãúÏûë</button>
            <button onclick="goToMain()">üè† Î©îÏù∏ÏúºÎ°ú</button>
        </div>
    </div>
    
    <!-- Ïù∏ÎùºÏù∏ Í≤åÏûÑ Ïä§ÌÅ¨Î¶ΩÌä∏ -->
    <script>
        /**
         * Sensor Shooter Game - Ïù∏ÎùºÏù∏ Î≤ÑÏ†Ñ
         * 2D Canvas Í∏∞Î∞ò ÏäàÌåÖ Í≤åÏûÑ
         */

        class SensorShooterGame {
            constructor() {
                console.log('üéØ INLINE SensorShooterGame ÏÉùÏÑ±Ïûê ÏãúÏûë');
                
                try {
                    // Canvas ÏóòÎ¶¨Î®ºÌä∏ ÏßÅÏ†ë Í∞ÄÏ†∏Ïò§Í∏∞
                    this.canvas = document.getElementById('gameCanvas');
                    if (!this.canvas) {
                        throw new Error('Í≤åÏûÑ Ï∫îÎ≤ÑÏä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
                    }
                    
                    this.ctx = this.canvas.getContext('2d');
                    this.canvas.width = 800;
                    this.canvas.height = 600;
                    
                    // Í≤åÏûÑ ÏÉÅÌÉú
                    this.gameStarted = false;
                    this.gameFinished = false;
                    this.score = 0;
                    this.health = 100;
                    
                    // Í≤åÏûÑ Í∞ùÏ≤¥Îì§
                    this.playerTurret = {
                        x: this.canvas.width / 2,
                        y: this.canvas.height / 2,
                        radius: 30,
                        aimX: this.canvas.width / 2,
                        aimY: this.canvas.height / 2,
                        angle: 0
                    };
                    
                    this.enemies = [];
                    this.projectiles = [];
                    
                    // ÌÉÄÏù¥Î®∏Îì§
                    this.lastTime = 0;
                    this.enemySpawnTimer = 0;
                    this.enemySpawnInterval = 2000; // 2Ï¥àÎßàÎã§ Ï†Å ÏÉùÏÑ±
                    this.autoShootTimer = 0;
                    this.autoShootInterval = 300; // 0.3Ï¥àÎßàÎã§ ÏûêÎèô Î∞úÏÇ¨
                    
                    // ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞
                    this.sensorData = {
                        connected: false,
                        tilt: { x: 0, y: 0 }
                    };
                    
                    console.log('‚úÖ Î™®Îì† Ïª¥Ìè¨ÎÑåÌä∏ ÏÉùÏÑ± ÏôÑÎ£å');
                    this.init();
                } catch (error) {
                    console.error('‚ùå SensorShooterGame ÏÉùÏÑ±Ïûê Ïò§Î•ò:', error);
                    throw error;
                }
            }
            
            init() {
                console.log('üéØ Í≤åÏûÑ Ï¥àÍ∏∞Ìôî ÏãúÏûë');
                
                // ÏÑºÏÑú Ïó∞Í≤∞ ÏãúÎèÑ
                this.connectToSensor();
                
                // ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏ (ÏãúÎÆ¨Î†àÏù¥ÏÖòÏö©)
                this.setupKeyboardControls();
                
                // Î°úÎî© ÌôîÎ©¥ Ïà®Í∏∞Í≥† Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏãúÏûë
                document.getElementById('loadingScreen').style.display = 'none';
                this.startCountdown();
                
                console.log('‚úÖ Í≤åÏûÑ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
            }
            
            connectToSensor() {
                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const port = window.location.protocol === 'https:' ? '8443' : '8080';
                    const wsUrl = `${protocol}//${window.location.hostname}:${port}`;
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('ÏÑºÏÑú WebSocket Ïó∞Í≤∞Îê®');
                        this.sensorData.connected = true;
                        this.updateSensorUI();
                        
                        // Í≤åÏûÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î°ú Îì±Î°ù
                        this.ws.send(JSON.stringify({
                            type: 'game_client_register',
                            deviceId: 'Shooter-Game-' + Math.random().toString(36).substr(2, 9),
                            timestamp: Date.now()
                        }));
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.type === 'sensor_data') {
                                const orientation = data.data?.orientation;
                                if (orientation) {
                                    // Ï°∞Ï§Ä Ï≤òÎ¶¨ (Í∞êÎèÑ Ï°∞Ï†ï)
                                    this.sensorData.tilt.x = (orientation.gamma || 0) * 0.05;
                                    this.sensorData.tilt.y = (orientation.beta || 0) * 0.05;
                                }
                                this.updateSensorUI();
                            }
                        } catch (error) {
                            console.error('ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ ÌååÏã± Ïò§Î•ò:', error);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        console.log('ÏÑºÏÑú WebSocket Ïó∞Í≤∞ ÎÅäÏñ¥Ïßê');
                        this.sensorData.connected = false;
                        this.updateSensorUI();
                        
                        // Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
                        setTimeout(() => this.connectToSensor(), 3000);
                    };
                    
                } catch (error) {
                    console.error('ÏÑºÏÑú Ïó∞Í≤∞ Ïã§Ìå®:', error);
                    this.sensorData.connected = false;
                    this.updateSensorUI();
                }
            }
            
            setupKeyboardControls() {
                // ÎßàÏö∞Ïä§Î°ú Ï°∞Ï§Ä (ÏãúÎÆ¨Î†àÏù¥ÏÖò)
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.playerTurret.aimX = e.clientX - rect.left;
                    this.playerTurret.aimY = e.clientY - rect.top;
                });
            }
            
            startCountdown() {
                let countdown = 3;
                const countdownScreen = document.getElementById('countdownScreen');
                const countdownNumber = document.getElementById('countdownNumber');
                
                countdownScreen.style.display = 'flex';
                countdownNumber.textContent = countdown;
                
                const countdownInterval = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        countdownNumber.textContent = countdown;
                    } else if (countdown === 0) {
                        countdownNumber.textContent = 'GO!';
                    } else {
                        clearInterval(countdownInterval);
                        countdownScreen.style.display = 'none';
                        this.gameStarted = true;
                        this.startGameLoop();
                        console.log('üéØ Í≤åÏûÑ ÏãúÏûë!');
                    }
                }, 1000);
            }
            
            startGameLoop() {
                const gameLoop = (currentTime) => {
                    if (this.gameFinished) return;
                    
                    const deltaTime = currentTime - this.lastTime;
                    this.lastTime = currentTime;
                    
                    this.update(deltaTime);
                    this.render();
                    
                    requestAnimationFrame(gameLoop);
                };
                
                requestAnimationFrame(gameLoop);
            }
            
            update(deltaTime) {
                if (!this.gameStarted || this.gameFinished) return;
                
                // ÌîåÎ†àÏù¥Ïñ¥ Ï°∞Ï§Ä ÏóÖÎç∞Ïù¥Ìä∏
                this.updatePlayerAim();
                
                // ÏûêÎèô Î∞úÏÇ¨
                this.autoShootTimer += deltaTime;
                if (this.autoShootTimer >= this.autoShootInterval) {
                    this.shoot();
                    this.autoShootTimer = 0;
                }
                
                // Ï†Å ÏÉùÏÑ±
                this.enemySpawnTimer += deltaTime;
                if (this.enemySpawnTimer >= this.enemySpawnInterval) {
                    this.spawnEnemy();
                    this.enemySpawnTimer = 0;
                }
                
                // Ï†Å ÏóÖÎç∞Ïù¥Ìä∏
                this.updateEnemies(deltaTime);
                
                // Ìà¨ÏÇ¨Ï≤¥ ÏóÖÎç∞Ïù¥Ìä∏
                this.updateProjectiles(deltaTime);
                
                // Ï∂©Îèå Í∞êÏßÄ
                this.checkCollisions();
                
                // UI ÏóÖÎç∞Ïù¥Ìä∏
                this.updateUI();
                
                // Í≤åÏûÑ Ïò§Î≤Ñ Ï≤¥ÌÅ¨
                if (this.health <= 0) {
                    this.gameOver();
                }
            }
            
            updatePlayerAim() {
                // ÏÑºÏÑú Îç∞Ïù¥ÌÑ∞ Ï†ÅÏö©
                if (this.sensorData.connected) {
                    this.playerTurret.aimX = this.playerTurret.x + this.sensorData.tilt.x * 200;
                    this.playerTurret.aimY = this.playerTurret.y + this.sensorData.tilt.y * 200;
                }
                
                // Ï°∞Ï§Ä Í∞ÅÎèÑ Í≥ÑÏÇ∞
                const dx = this.playerTurret.aimX - this.playerTurret.x;
                const dy = this.playerTurret.aimY - this.playerTurret.y;
                this.playerTurret.angle = Math.atan2(dy, dx);
            }
            
            shoot() {
                const speed = 500;
                const projectile = {
                    x: this.playerTurret.x,
                    y: this.playerTurret.y,
                    dx: Math.cos(this.playerTurret.angle) * speed,
                    dy: Math.sin(this.playerTurret.angle) * speed,
                    radius: 5,
                    color: 'yellow',
                    alive: true
                };
                
                this.projectiles.push(projectile);
            }
            
            spawnEnemy() {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                const radius = 15 + Math.random() * 15;
                
                switch (side) {
                    case 0: // ÏúÑ
                        x = Math.random() * this.canvas.width;
                        y = -radius;
                        break;
                    case 1: // Ïò§Î•∏Ï™Ω
                        x = this.canvas.width + radius;
                        y = Math.random() * this.canvas.height;
                        break;
                    case 2: // ÏïÑÎûò
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + radius;
                        break;
                    case 3: // ÏôºÏ™Ω
                        x = -radius;
                        y = Math.random() * this.canvas.height;
                        break;
                }
                
                // ÌîåÎ†àÏù¥Ïñ¥Î•º Ìñ•ÌïòÎäî Î∞©Ìñ• Í≥ÑÏÇ∞
                const angle = Math.atan2(this.playerTurret.y - y, this.playerTurret.x - x);
                const speed = 50 + Math.random() * 50;
                
                const enemy = {
                    x: x,
                    y: y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    radius: radius,
                    color: `hsl(${Math.random() * 360}, 70%, 50%)`,
                    health: 3,
                    alive: true
                };
                
                this.enemies.push(enemy);
            }
            
            updateEnemies(deltaTime) {
                const dt = deltaTime / 1000; // Ï¥à Îã®ÏúÑÎ°ú Î≥ÄÌôò
                
                this.enemies.forEach(enemy => {
                    if (!enemy.alive) return;
                    
                    enemy.x += enemy.dx * dt;
                    enemy.y += enemy.dy * dt;
                    
                    // ÌîåÎ†àÏù¥Ïñ¥Ïóê ÎèÑÎã¨ÌñàÎäîÏßÄ ÌôïÏù∏
                    const dist = Math.sqrt(
                        Math.pow(enemy.x - this.playerTurret.x, 2) + 
                        Math.pow(enemy.y - this.playerTurret.y, 2)
                    );
                    
                    if (dist < this.playerTurret.radius + enemy.radius) {
                        this.health -= 10;
                        enemy.alive = false;
                    }
                });
                
                // Ï£ΩÏùÄ Ï†Å Ï†úÍ±∞
                this.enemies = this.enemies.filter(enemy => enemy.alive);
            }
            
            updateProjectiles(deltaTime) {
                const dt = deltaTime / 1000;
                
                this.projectiles.forEach(projectile => {
                    if (!projectile.alive) return;
                    
                    projectile.x += projectile.dx * dt;
                    projectile.y += projectile.dy * dt;
                    
                    // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ Ï†úÍ±∞
                    if (projectile.x < 0 || projectile.x > this.canvas.width ||
                        projectile.y < 0 || projectile.y > this.canvas.height) {
                        projectile.alive = false;
                    }
                });
                
                // Ï£ΩÏùÄ Ìà¨ÏÇ¨Ï≤¥ Ï†úÍ±∞
                this.projectiles = this.projectiles.filter(projectile => projectile.alive);
            }
            
            checkCollisions() {
                this.projectiles.forEach(projectile => {
                    if (!projectile.alive) return;
                    
                    this.enemies.forEach(enemy => {
                        if (!enemy.alive) return;
                        
                        const dist = Math.sqrt(
                            Math.pow(projectile.x - enemy.x, 2) + 
                            Math.pow(projectile.y - enemy.y, 2)
                        );
                        
                        if (dist < projectile.radius + enemy.radius) {
                            projectile.alive = false;
                            enemy.health--;
                            
                            if (enemy.health <= 0) {
                                enemy.alive = false;
                                this.score += 10;
                            }
                        }
                    });
                });
            }
            
            render() {
                // ÌôîÎ©¥ ÏßÄÏö∞Í∏∞
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ÌîåÎ†àÏù¥Ïñ¥ Ìè¨ÌÉë Í∑∏Î¶¨Í∏∞
                this.drawPlayerTurret();
                
                // Ï†ÅÎì§ Í∑∏Î¶¨Í∏∞
                this.enemies.forEach(enemy => {
                    if (enemy.alive) {
                        this.ctx.fillStyle = enemy.color;
                        this.ctx.beginPath();
                        this.ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
                
                // Ìà¨ÏÇ¨Ï≤¥Îì§ Í∑∏Î¶¨Í∏∞
                this.projectiles.forEach(projectile => {
                    if (projectile.alive) {
                        this.ctx.fillStyle = projectile.color;
                        this.ctx.beginPath();
                        this.ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            }
            
            drawPlayerTurret() {
                const ctx = this.ctx;
                
                // Ìè¨ÌÉë Î≤†Ïù¥Ïä§
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.playerTurret.x, this.playerTurret.y, this.playerTurret.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Ìè¨ÌÉë Î∞∞Îü¥
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(this.playerTurret.x, this.playerTurret.y);
                ctx.lineTo(
                    this.playerTurret.x + Math.cos(this.playerTurret.angle) * 40,
                    this.playerTurret.y + Math.sin(this.playerTurret.angle) * 40
                );
                ctx.stroke();
            }
            
            updateUI() {
                document.getElementById('scoreDisplay').textContent = this.score;
                document.getElementById('healthDisplay').textContent = this.health;
            }
            
            updateSensorUI() {
                const status = this.sensorData.connected ? 'üì° ÏÑºÏÑú Ïó∞Í≤∞Îê®' : 'üì° ÏÑºÏÑú Ïó∞Í≤∞ ÎåÄÍ∏∞Ï§ë...';
                document.getElementById('sensorConnection').textContent = status;
                document.getElementById('aimX').textContent = this.sensorData.tilt.x.toFixed(2);
                document.getElementById('aimY').textContent = this.sensorData.tilt.y.toFixed(2);
                document.getElementById('accelMag').textContent = '0.00';
            }
            
            gameOver() {
                this.gameFinished = true;
                document.getElementById('gameOverScreen').style.display = 'flex';
                document.getElementById('finalScore').textContent = this.score;
                console.log('üéØ Í≤åÏûÑ Ïò§Î≤Ñ! ÏµúÏ¢Ö Ï†êÏàò:', this.score);
            }
        }

        // Ï†ÑÏó≠ Ìï®ÏàòÎì§
        function restartGame() {
            location.reload();
        }

        function goToMain() {
            window.location.href = '/';
        }

        // Í≤åÏûÑ Ï¥àÍ∏∞Ìôî
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üéØ INLINE ÏÑºÏÑú ÏäàÌÑ∞ Í≤åÏûÑ DOM Î°úÎìú ÏôÑÎ£å');
            
            try {
                window.sensorShooterGame = new SensorShooterGame();
                console.log('‚úÖ INLINE ÏÑºÏÑú ÏäàÌÑ∞ Í≤åÏûÑ Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ!');
            } catch (error) {
                console.error('‚ùå INLINE Í≤åÏûÑ Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.innerHTML = 
                        `<h1>üö´ Í≤åÏûÑ Ï¥àÍ∏∞Ìôî Ïã§Ìå®</h1><p>Ïò§Î•ò: ${error.message}</p>`;
                }
            }
        });
    </script>
</body>
</html>